Jun 25th
First three tests completed successfully: Create_And_Test_Line, Test_AllButOneFound, Test_UnconclusiveResult. The Line class is the basic box that holds the contents of one category. The top row holds the index, the second the category identifier (A, B, C...) and the values if these are required. The third row is an array of strings that will hold known relational information. At this initial stage, only positive relations are cited in the third row. Might have to introduce a fourth row to hold negative relations. 
The idea for the line came from thinking about how to query a relative clause ("A1(B) - A2(B) = 25"). With the Line class, the whole statement can be passed to the Line and, as the values are held for comparative items, it can deduce and return any statements based on the information it holds (e.g. "A1 != B1; A2 != B5").

Still need to reconsider First Order Logic to see if I can use that as the basic semantic representation of such clauses, or whether another translation will have to happen later for the prover to keep things simple and manageable here.
------------

Jun 29th
After initially creating just one Relation class to hold all rule variants, it became apparent that a bit of inheritance would better handle the different logic required for most methods depending on the rule type. A factory was therefore created to control creation logic.

Added a fourth row to the Line class to hold information on negative relations.

Spent a while trying to think of a good name for "considerRelation", a function that passes a rule to a Line and returns true or false if the Line was able to use it. As a Line might create more rules in the process of considering a relation, this may need to be rethinked. Perhaps it's the collection of rules that uses the Line, and not vv?

Have created a namespace called Representation which has the characters I've chosen to use in Relations for equality, comparison and ownership. The items here are referenced by Relation classes when identifying items within a rule and checking the rule type.

Created a basic exception class for use when attempting to retrieve a specific item but it is not clear which item is desired. Need to read more about custom exceptions in C#. It's called InconclusiveException, but is currently specific to one scenario.

Created a separate test for the Relation class. (Tests were created in the LineTest file originally.)

After debating where to store the considerRelation function, given it's use of both a line and a relation, a brains class, Deducer, was created and so begins the step-by-step logical processing.
------------

Jun 30th
Exciting morning. Have created a family of Calculators which will perform the necessary calculation of relative items for a Line. The Line class holds a Calculator, which is initialised at the same time as a Line is created with a keyword. This keyword determines the type of Calculator that will be created. So far only the NumberCalculator is functional. These can be created as puzzles require. When a new keyword is encountered the logic for it will be held in Representation.Relations and the Calculator class.

Lines can now consider quantified relative numeric rules. 

Also created the DeducerTest file to complete the parts of Deducer begun last night. The Deducer holds a collection of lines, created based on the size of the puzzle.

Line now works with the calculator and comparative terms to understand relative relations! Need to build some tests, tho.
-----------

Jul 3rd
Slow day at work, so worked on getting VS2012 up in office to enable working from work and home. Once complete, got to fixing the UI a bit. There are now functioning switches from the main menu to settings window and the basic solver window, although nothing happens in the latter yet.
Filled in some basic ideas for settings options. 

Created a base file, Controller, to be the cross-module file that will use the individual modules to control the whole software as it works together. This was not created from a test file, as whether it would work was a test in itself with help from IDE hints.

Renamed Line to Category to use the abstract object it represents, not a name linked to its representation in code. Code is therefore now full of cats...	  

Created the shell of the Parser module and a few shells of classes it will need to allow build success.
Created a shell of the all-important Puzzle class.
-------------

Jul 6th
Let's get to it!
Might leave UI for a bit and assume all methods of Controller can populate UI elements and respond to events from UI. Don't like the tight coupling of UI elements to the controller anyway, although the Controller is quite coupled to the specific modules too. Might look for a way to add another layer of abstraction in the mix when it's time to put these two parts together.

Introduced CategoryBuilder to avoid Category having several constructors available. (Added InternalsVisibleTo attribute in CleverZebra for LogixTests to keep internals internal.)

Started rearranging modules into actual separate projects as otherwise they're not really independent entities. Now everyone needs references adding, but this suggests I've not gotten the coupling right. Need to work out what the interface should be between the CleverZebra project running everything and the now-separate components, Logix and Parser. Will cheat for now and add the references whilst waiting for a spot of guidance and lunching.

No guidance received, but by separating out the Representation classes - Puzzle, Solution, Relations - each module now references these and CZ also references Logix and Parser, so coupling is much better. If the representation of anything were to change then I'd want each concrete item to derive from an interface and this interface is what my modules would reference... but I don't think this will happen in the course of this project and so won't spend time adding in that layer of abstraction.

TODO: Think about how exceptions will be handled, i.e. passing feedback to the GUI so that it can continue.

Whilst translating the first puzzle into statements for testing, I realised the Logix unit may not need to know anything about the values and comparative terms. The parser should be translating them sufficiently that there remains no need for the Logix unit to do so. "Zachary lost his hat two days before Gareth" should be translated simply to A1(B)-A2(B)=2 if 2 is the index difference representing two days. If it is more complicated - say unequally separated monetary amounts, should this be taken into full consideration in the parser, however? I think the difference should be the number of units and logix should check whether each item is separated by one unit (easy) or whether it's a varying amount. This means Parser will be leaving numbers as they are, (1 day, £50) and Logix will be deciding what this means in relation to the available options.

Spent many, many hours getting the Deducer very nearly (hopefully...) solving the first test puzzle. Properly expanded the solving algorithm in Deducer.Go() to include check stages. There's a constant for the maximum number of turns the deducer should attempt to solve the puzzle in and one for the number of rules it should get from the "Grid Check" before returning to the main clues.
Latest bug - when we finally get the deduced rule that'll set 'em all on fire, cat.findTarget in considerRelationToCategory bombed with a null value. Walk through that one as the comparative rule is finally handled through the section where one value is known and we should be on the home straight.
------------

Jul 7th
After realising the checkDeductibles wasn't looking for all-but-one-negated and adding that in, the first problem was successfully solved. It took 57 turns, which is pretty lame, though. I think this is because it adds every reverse negative relation in there too - the equivalent of completing all the crosses even when there's only one tick left and it's coming. In a 4 x 3 puzzle there are only a total of 51 squares in the grid, though, so this definitely isn't that efficient. 

Next up is to actually return the solution in words for Deducer and then play with the ordering of the Deducer's Go() algorithm to see if the number of turns can be improved. Even though this only takes 49ms to run to completion. Ah, digital magickery.

After lunch... Solution returned was actually incorrect. Looking into it this was because the Reductio function removed the comparative relation and I'd actually typed it up the wrong way round anyway. a few things to work on: Prevent Reductio from dropping relative relations, set up comparative logic to use the calculator properly (Values might have to be set for the particular test problem being used), potentially limit the frequency with which Reductio is called and maybe push discovered positive rules further up the queue to help speed up resolution.

Solution found! Told addRelation to check if a rule has already been processed before adding it to the queue, except for relatives, which always go back in. Experimenting with REDUCTIO_SPACING: 10->39 turns, 8->35 turns, 7->38 turns, 5->37 turns, 3->48 turns, 1->52 turns.
Using 8 as the spacing due to the above results, dropping REDUCTIO_RULES from 20 to 4 had no effect. Upping it to 100 also had no effect. Might just remove that one. Also added an extra if block in Reductio so it doesn't bother creating negative rules between two items in the same category.

When thinking about where the function 'enterCategoryValues' should really live I realised that the current method of tagging a puzzle in need of calculators is pretty slim. The keyword(s) are attributes of the whole puzzle, not the individual categories. Might have to change this in the source, as they do really belong with the categories and not the puzzle as a whole, though it is nice to be able to see straight off what specialties a puzzle uses as a gauge of difficulty.
----------
Jul 8th 
Second puzzle was actually much simpler, involving only direct relations, and was solved first time in 6 turns.
Puzzle three, the first 4x4, was inconclusive. Investigating why, this turned out to be because a negative relation needed to be entered in the category for an item (C4) which was added as a positive match to one item in the category so that another item could be deduced (!C2, !C3, !C4, => C1). Will add this to the category's method of adding an item.
Added this extra stage to the category but also found a couple of bits to fix: One of the reasons for many repeated relations out of Reductio was a list of negatives being looked for possible cross-reference relations was not being deduplicated before processing. Added in a Distinct. Also added in a small clause to the checkForMatch function so that it doesn't check, find three negatives for a category and produce a positive relation for the one remaining if this is already known. Puzzle three completes, but takes 106 turns. Don't know if this is due to the increase in size or redundant rule placement. Maybe should prioritise for next work session the emphasis on positive relations.

As the timing of all tests has so far been tiny, the speed of the test seems like a less scientific way to test the algorithm's effectiveness compared to the number of turns it takes to find the solution. As I am considering just in the cause of final development of this stage the queue-jumping of positive relations for processing, this ties in with my belief that potentially dropping in positives as early as possible will increase efficiency. Will therefore create the method with positive relation shifting as the alternative, second, model. The other deviation in algorithmic methods that was proposed was to avoid performing a check of reduction to absurdium until after all of the main rules have been considered. Even after watching the first few debug runs, however, it became obvious that performing an absurdium check after every rule consideration was redundant. Maybe in Algorithm 2 it can be reinstated for after every positive rule is considered (or else every 8th).
----------
Jul 10th
Decided that considerRelationToCategory shouldn't be in Deducer, but Category. Moved it but then the inverse, which relies on telling another category to update its members can't be called. But considering each rule is considered by each category in turn, this actually shouldn't matter. Switched deducers considerRelationToCategories to call the function in the categories rather than in itself and the test still passed, completing the puzzle in exactly the same number of turns. Good good.
After moving this and thinking about the bigger picture, I decided that it would be better if the category adding a matched item triggered an event that the Solution class would (indirectly) respond to, rather than having a separate stage for the Solution class to consider rules within Deducer's Go() method. This seems neater and may result in quicker solution if this is triggered also at the point at which a positive relation is created, rather than just applied. Will plug in and see the results.
WIN! Puzzle 3 is now solved in just 55 turns! Time halved! Coding is magic. Better than the reduction in turns... the third test puzzle just completed in 8ms, whereas the quickest I'd seen it previously was ~80ms.
----------
Jul 11th
Spoke to Roman and Michael at BBK and in explaining the difficulty I found in finding a good place for the Puzzle class, I realised that it could possibly be broken down. Each user of the puzzle would have a PuzzleBuilder and would be fed just the bits it's interested in with Controller holding the master information, as provided by the input Puzzle (i.e. as Representation has it). Parser and Logic would have their own PuzzleBuilder classes which would implement CleverZebra.IPuzzleBuilder and of the potential interface methods, implement just the ones it needs. This would be better from an Object-Oriented point of view, but the fellas said I should worry about the program actually doing what it needs to much more than the manner in which it does so, by which standard the current method of them all using the Representation.Puzzle class is fine.
* Make another Event/EventGenerator/EventListener set for SolveComplete which could report back to Controller the success, time taken and number of turns that Deducer took to reach its conclusion.
---------
Jul 12th
SolveCompleteEvent in action. Unlike my little finger. Results passed to Controller.
-------
Jul 13th
Added a fourth test, a 4x5. Originally failed because I mistranslated a rule but also meant I spotted that the solution needed an extra conditional in place to prevent a rule being added on a new line if there was already a potential gap in lines currently filled. Quite surprised this didn't cause any issues before now. Must be rare that the puzzle writers allow you to complete a whole row before lots of potential pairings are in place. Due to the code change required I will add in one more test.
... And just as well. Found a new relation type! "Oliver Ofgard is clearing a step at a house numbered higher than the other resident clearing a step". There are two step options, "Back step" and "Front step" and whilst the first bit (Oliver is clearing a step) can be translated as a list of negatives rather than creating an OR rule, there's no current way of writing up the comparative relation to the other one-of-steps. A simple If.. Then.. Else will be enough to represent this clue. 
?A4=C1?A4(D)>C3(D):A4(D)>C1(D)
How to handle this clue? Before the first part is known, the resulting statement cannot be considered, unless both of the second parts (C3(D), C1(D)) are known, in which case the first part can be handled. Maybe it could be coupled with an inverse therefore:
?C3(D)>C1(D)?A4=C3:A4=C1
How Deducer should handle Conditionals: They are kept until the front condition can be answered, at which point they simply return the correct new relation for processing and are removed from the clues bank.
ConditionalRelation class created. Now to add logic to Deducer...
* A reminder note that Number calculator doesn't actually perform calculations yet, but is relying upon categories being translated into values of 1,2,3,4,5 with a standard interval between them, which is what the difference points to. In the fifth test there is a non-standard interval (1,2,3,5,6) and I'd imagine to solve the puzzle the calculator will need to know that the higher item cannot be 5 as there is no 4 for the lower item to be (and vice versa) when given x(Y)-x'(Y)=1.
Puzzle five causes a particular situation that is difficult to mechanise for a compluter solver: There are three unassigned items in Category D and lots of comparative rules relating to them: B4(D) < A3(D), B4(D) > C1(D), A3(D) > C1(D). I think I need to introduce a triple relation (C1(D)<B4(D)<A3(D)) as these came from one clue (B4 is less than A3 but greater than C1). As long as this happens in any other situation requiring this logic, this will then fix it. May need to think of a way to automatically generate this from separate comparatives, though. Maybe a check as part of Absurdio? Will just add the Relation and logic for now.
Taking a step back because I managed to walk through the solution by hand without using a three way relative. I think it's just the missing calculator logic that's holding this one back. An extra negative result should be found by considering B1(D)-C4(D)=2 and the fact that not all potential values of D have a value 2 away. (e.g. in fifth test values are 1,2,3,5,6 and therefore B1 cannot be D6 because C4 cannot have the value 4. Need to add this in to the createNegativesToBounds function, but for now I must sleep.
*Might be a good idea to fix the addInverse to happen automatically as an event when a category adds a relation.
-------------
Jul 14th
Fifth test finally working! The Number Calculator's getImpossibles was checking the same item as the compared to and therefore missing situations where it could deduce a negative because the items higher were negated. So for B4(D)>C1(D) if we had established that B4 could not be D5 then it wasn't negating C1 against D4 because the function was looking first to see whether B4 was negated a D4 and would then have gone up to D5. Added one/Subtracted one from the starting index here for lower/higher comparatives and all tests working fine, including Problem 5. Finally!!! Taking 161 turns, though, so really need to add in that auto-Inverse event.

Time to move onto the Parser, I think. Starting to fill out the Category Dictionary, but it's bedtime now. Need to add one item into the dictionary's codes (A1) and words (Zachary) for each non-category-title word in each category.
----------
Jul 17th
Started building the basic structures necessary for ParserTests. First_Parser_Test working, but this simply confirmed the set up of puzzle items and Parser constructors.
Check_Dictionaries is the second test which allows a visual check of the dictionaries created. Actually, I'll automate that check. Cool, automated now and passing.
Next test - Tagging time! Starting with puzzle 2, Rainy Day Women, which is probably the easiest. It does require me to straight away decide what to do about apostrophes, though. In this puzzle the "Shop" category has the names "Haven's", "Lee's" and "Port's". These will be added to the category dictionary as one word and appear in the text as one word. In other situations, however, it may be when talking about named individuals that they appear in the text followed by an apostrophe to connect them to the next category item ("Bob's cat"). I suppose it might be possible to say if (item or item +"'s" == testWord) to cover this situation but not allow for reduction when the category item actually includes an apostrophe.
--------
Jul 20th
Finished the dictionary word to tag functions. Started to try condensing the tag patterns, but I think I'm going to need that text again, Theory of Syntactic Recognition for Natural Language Processing, as I'm finding it hard to algorithmize the condensing process and need to re-read the bit about using buffers, as that must be the way to go. I can instead add the basics of the other rule type I identified as a potential requirement: A1(B)<£100 / A1(B)<B4. The parser will be to create the second of these if the amount being compared to is a category item, otherwise the comparator's difference will have to be provided as it is and the Calculator the category will have to determine what it can from the literal amount. I can't recall every coming across the first situation, but it shouldn't be impossible to add in. The hardest bit will be having the keyword-specific words for the parser to recognise all-encompassing enough that the "£100" is recognised as an important word. For currency anything beginning with a monetary sign can be kept. Anything that is purely a number will be kept (int or double).
---------
Jul 21st
Went through the puzzle book trying to find an example of the potential new rule and couldn't find an example to use in the test. Thought about it, though, and amended RelativeRelation to be considering whether it actually has two mentioned items or not, so there is an untested pathway now for Single Item Relatives to take. All other tests (save current parser test in progress) still passing.
Have begun properly the process of condensing tag patterns. Created a whole bunch of functions in Tagger based upon a sort of flowchart algorithm put together on pen and paper. Created a new ParsingBuffer class which acts as the buffer for Tagger to hold previous items whilst going through and considering the next one(s). If Tagger can determine what to do with a tag based on its appearance alone then it adds it to the result and wipes the buffer. The buffer is used when a tag has more than one option, or when the tag presented may only be in the end result if it is followed by particular others. Whilst creating the function frames for this I hesitated about where some logic should be held. Should the TermsDictionary determine whether one Term tag must be followed by the next? In the end I decided that the dictionaries should only be concerned with turning natural language words to tags and Tagger should be the entity that knows about tags and tag combinations.

*Whilst originally words with multiple tag options are just represented by comma-separated tags, the tag collection should possibly be enclosed in {} so that when it's read as part of the buffer it is obvious which buffer items were multiple. For now the only fledged function that needs to consider different parts of each item in the buffer (buffer.dropNonTermTags()) is assuming there may be {} and including these chars in the spit function to deal with all individual tags within. It will cope whether there is or isn't {} in the end.
------
Jul 25th
Completing more of the Tagger's methods. Realised that multiple-options will have to be in braces so isTermTag can work based on string[0] == 'T'. isMixedTag is already checking each part, once split by commas or braces, as isTerm or isCat, so no amendments needed.
Created PatternBank for matching term patterns. This now contains the logic for checking whether one termTag should be followed/preceded by anything and its methods are used by term-focused logic in Tagger.
Check_Complete_Tagging now working :) Can either move on to the Translator next or test out more complicated clues. (This test included no comparatives.)
Ran all tests and Check_Dictionary_Creation failed because it does parser.Read() and it had some comparative statements in there. Fixed that up and now all's working. I win. So I guess next up is Translator. Test for Translated rules created.
-------
Jul 27th
Completed functions in Translator to pass the first test (which has the simplest sorts of relations, direct (both positive and negative), only. Moving on to the next problem text which features comparatives.
When writing up the check-relations for the second test I realised that the decision on handling comparative amounts hasn't truly been taken yet. In this puzzle on category item "happened two days before" another. In the LogicTest for this puzzle I've translated days to numbers and set a numeric difference. The translator is going to be given "Tn(two), Tq(days), Tp(before)" and needs to know what to do with this. It does not currently have access to the categorical information, so what can it make into a relation? The Parser class is the only thing in the module that currently has access to categorical information. Like Tagger has PatternBank for reference and Deducer has Calculator, maybe Translator needs a buddy to work these things out. Really I want the relation to be A3(C) - A1(C) = 2, with days having been confirmed as the correct unit for the category. By actually implementing the Date Calculator, this should be able to select Monday/Wednesday/Friday from the difference of 2 days. Will continue in Translator aiming for this result and then complete the Date (or a separate Day?) Calculator in Logix.
The TermDictionary is where keyword-related stuff happens. Forgot that. So actually, if the words in the clue are caught by term dictionary, they'll be translated into quantifier/Comparative tags and these can simply be translated into the right phrase by translator. So you have Tn(2) and currently Tq(days) followed by Tp(earlier) but I don't think q needs to have it's unit in brackets. If the unit could vary (week/month) then a test will fail and we'll look at getting TermDictionary to do more than relay the given item. But I don't think this does. It can be done as an extension later, if necessary. All parts of second test's puzzle translating except for the comparative now. Lunchtime.
Cracked it! TermDictionary should return in the brackets of q the category letter that the quantitive term relates to! That way translator has the category item it needs.
Changed where category keywords were stored and how they were held in TermsDictionary, and now Tagger's tagClues function returns Tq(C). Think I may need to do the same for the numbers and direction words, though. Thinking of pairs of words to indicate direction and need to create a text-to-int function.

Text-to-int complete, comparative handling complete, Translator therefore complete at this complexity level and Second translation test passed!
-------
Jul 28th
Creating next level of tests for parser (tagging and translating).
Quite complex! Have added relation patterns to pattern bank and am starting to get Translator to handle longer phrases beyond the first few patterns met. A chain of category items with Td can now be handled using a buffer technique again. (The same ParsingBuffer class is being used to accomplish, making use of the ToString() function and a couple of others made necessary. With time it would be good to split this into two classes, but for now it's doing what I need it to.) The realisation of the need for a buffer came when drafting the algorithm for handling two patterns: B2 Td C2 Td A4 and B4 A3 Td D4. The buffer allows the flow of logic to move left-right across the pattern, making a relation when a complete pattern is found and holding onto the final item to begin the next pattern.
Only patterns C,C and C,Td,C have been fleshed out for now. The final pattern required for the third puzzle is a more complicated one - B3 A Tx(1) Tp(+) C C3 and for now my brain is too fried to continue. Need to consider the categories and put the correct one into a Tq() tag and then it can be passed to the getRelationsUsingBuffer() function and pattern logic filled in.
-----
Aug 3rd
Pathway for two more patterns added in (C,A,Tx,Tp,C & C,Tx,Tp,A,C) and third test now completing successfully. Should have all the pieces to complete the other patterns now, so adding those in next before leaving ParserTest for a bit.
All patterns translated, though some remain untested. All written tests still passing.
Moved the Results class to Representation so Controller keeps a record of the stats rather than receiving a list of objects.
More of the GUI done. Looking lovely. Controller being a singleton allows all windows to get the bits of the puzzle text they require, which is more useful that ever here. The listbox of puzzles contains all items found in the main puzzle source.
Added a solver page to navigate to after selecting a puzzle and created frames for clues and Solution box. Solution box doesn't currently show values in table cells, which is annoying. Should create a test button that tries to add something to a cell and see if that works.
-------
Aug 5th
Have spent today working some more on the UI, to little progress, seemingly. Have hooked up the events that report back a new entry for the solution and this works... the first time. Returning to the Puzzle form and clicking "Begin" again, however, causes you to travel back in time once the Solve process is underway: The solution area is initially set up correctly, ready for the new puzzle, but then the events coming back from Logix actually seem to hop back to a previous instantiation - the frmSolver.data is that from the first puzzle, not the current puzzle, and the datagridview has no columns or rows. (Once it had columns, but not rows). Do not know why. Will try with a refreshed head anon. Also need to work out how to slow down the whole process for entertainment value (User can watch puzzle be solved). Less important, though.
------
Aug 11th
Above issue with datagridview was from failing to unhook an event listener. Spotted that one very late that evening. Today I looked into how to attach Vampire, only to discover the software's not available at the moment as a new version will be released soon. Spent time looking for an alternative, but nothing brilliant found yet.
Also quickly hooked up the results to the stats area of the Solver form and added in the path for the "Go Slow" setting to travel through to Solution, where, after triggering the UI update event, a thread sleep will allow progress to be witnessed in steps. Need to wire the first bool drop to the settings page. Also hooked up the main form closing event to pop up a "Sure you wanna?" dialog before exiting. And somehow the keywords weren't being passed to Deducer. ???. Added them in, now, and will see the number of puzzles now working from start to end.