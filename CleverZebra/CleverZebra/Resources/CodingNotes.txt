Jun 25th
First three tests completed successfully: Create_And_Test_Line, Test_AllButOneFound, Test_UnconclusiveResult. The Line class is the basic box that holds the contents of one category. The top row holds the index, the second the category identifier (A, B, C...) and the values if these are required. The third row is an array of strings that will hold known relational information. At this initial stage, only positive relations are cited in the third row. Might have to introduce a fourth row to hold negative relations. 
The idea for the line came from thinking about how to query a relative clause ("A1(B) - A2(B) = 25"). With the Line class, the whole statement can be passed to the Line and, as the values are held for comparative items, it can deduce and return any statements based on the information it holds (e.g. "A1 != B1; A2 != B5").

Still need to reconsider First Order Logic to see if I can use that as the basic semantic representation of such clauses, or whether another translation will have to happen later for the prover to keep things simple and manageable here.
------------

Jun 29th
After initially creating just one Relation class to hold all rule variants, it became apparent that a bit of inheritance would better handle the different logic required for most methods depending on the rule type. A factory was therefore created to control creation logic.

Added a fourth row to the Line class to hold information on negative relations.

Spent a while trying to think of a good name for "considerRelation", a function that passes a rule to a Line and returns true or false if the Line was able to use it. As a Line might create more rules in the process of considering a relation, this may need to be rethinked. Perhaps it's the collection of rules that uses the Line, and not vv?

Have created a namespace called Representation which has the characters I've chosen to use in Relations for equality, comparison and ownership. The items here are referenced by Relation classes when identifying items within a rule and checking the rule type.

Created a basic exception class for use when attempting to retrieve a specific item but it is not clear which item is desired. Need to read more about custom exceptions in C#. It's called InconclusiveException, but is currently specific to one scenario.

Created a separate test for the Relation class. (Tests were created in the LineTest file originally.)

After debating where to store the considerRelation function, given it's use of both a line and a relation, a brains class, Deducer, was created and so begins the step-by-step logical processing.
------------

Jun 30th
Exciting morning. Have created a family of Calculators which will perform the necessary calculation of relative items for a Line. The Line class holds a Calculator, which is initialised at the same time as a Line is created with a keyword. This keyword determines the type of Calculator that will be created. So far only the NumberCalculator is functional. These can be created as puzzles require. When a new keyword is encountered the logic for it will be held in Representation.Relations and the Calculator class.

Lines can now consider quantified relative numeric rules. 

Also created the DeducerTest file to complete the parts of Deducer begun last night. The Deducer holds a collection of lines, created based on the size of the puzzle.

Line now works with the calculator and comparative terms to understand relative relations! Need to build some tests, tho.
-----------

Jul 3rd
Slow day at work, so worked on getting VS2012 up in office to enable working from work and home. Once complete, got to fixing the UI a bit. There are now functioning switches from the main menu to settings window and the basic solver window, although nothing happens in the latter yet.
Filled in some basic ideas for settings options. 

Created a base file, Controller, to be the cross-module file that will use the individual modules to control the whole software as it works together. This was not created from a test file, as whether it would work was a test in itself with help from IDE hints.

Renamed Line to Category to use the abstract object it represents, not a name linked to its representation in code. Code is therefore now full of cats...	  

Created the shell of the Parser module and a few shells of classes it will need to allow build success.
Created a shell of the all-important Puzzle class.
-------------

Jul 6th
Let's get to it!
Might leave UI for a bit and assume all methods of Controller can populate UI elements and respond to events from UI. Don't like the tight coupling of UI elements to the controller anyway, although the Controller is quite coupled to the specific modules too. Might look for a way to add another layer of abstraction in the mix when it's time to put these two parts together.

Introduced CategoryBuilder to avoid Category having several constructors available. (Added InternalsVisibleTo attribute in CleverZebra for LogixTests to keep internals internal.)

Started rearranging modules into actual separate projects as otherwise they're not really independent entities. Now everyone needs references adding, but this suggests I've not gotten the coupling right. Need to work out what the interface should be between the CleverZebra project running everything and the now-separate components, Logix and Parser. Will cheat for now and add the references whilst waiting for a spot of guidance and lunching.

No guidance received, but by separating out the Representation classes - Puzzle, Solution, Relations - each module now references these and CZ also references Logix and Parser, so coupling is much better. If the representation of anything were to change then I'd want each concrete item to derive from an interface and this interface is what my modules would reference... but I don't think this will happen in the course of this project and so won't spend time adding in that layer of abstraction.

TODO: Think about how exceptions will be handled, i.e. passing feedback to the GUI so that it can continue.

Whilst translating the first puzzle into statements for testing, I realised the Logix unit may not need to know anything about the values and comparative terms. The parser should be translating them sufficiently that there remains no need for the Logix unit to do so. "Zachary lost his hat two days before Gareth" should be translated simply to A1(B)-A2(B)=2 if 2 is the index difference representing two days. If it is more complicated - say unequally separated monetary amounts, should this be taken into full consideration in the parser, however? I think the difference should be the number of units and logix should check whether each item is separated by one unit (easy) or whether it's a varying amount. This means Parser will be leaving numbers as they are, (1 day, £50) and Logix will be deciding what this means in relation to the available options.

Spent many, many hours getting the Deducer very nearly (hopefully...) solving the first test puzzle. Properly expanded the solving algorithm in Deducer.Go() to include check stages. There's a constant for the maximum number of turns the deducer should attempt to solve the puzzle in and one for the number of rules it should get from the "Grid Check" before returning to the main clues.
Latest bug - when we finally get the deduced rule that'll set 'em all on fire, cat.findTarget in considerRelationToCategory bombed with a null value. Walk through that one as the comparative rule is finally handled through the section where one value is known and we should be on the home straight.
------------

Jul 7th
After realising the checkDeductibles wasn't looking for all-but-one-negated and adding that in, the first problem was successfully solved. It took 57 turns, which is pretty lame, though. I think this is because it adds every reverse negative relation in there too - the equivalent of completing all the crosses even when there's only one tick left and it's coming. In a 4 x 3 puzzle there are only a total of 51 squares in the grid, though, so this definitely isn't that efficient. 

Next up is to actually return the solution in words for Deducer and then play with the ordering of the Deducer's Go() algorithm to see if the number of turns can be improved. Even though this only takes 49ms to run to completion. Ah, digital magickery.

After lunch... Solution returned was actually incorrect. Looking into it this was because the Reductio function removed the comparative relation and I'd actually typed it up the wrong way round anyway. a few things to work on: Prevent Reductio from dropping relative relations, set up comparative logic to use the calculator properly (Values might have to be set for the particular test problem being used), potentially limit the frequency with which Reductio is called and maybe push discovered positive rules further up the queue to help speed up resolution.

Solution found! Told addRelation to check if a rule has already been processed before adding it to the queue, except for relatives, which always go back in. Experimenting with REDUCTIO_SPACING: 10->39 turns, 8->35 turns, 7->38 turns, 5->37 turns, 3->48 turns, 1->52 turns.
Using 8 as the spacing due to the above results, dropping REDUCTIO_RULES from 20 to 4 had no effect. Upping it to 100 also had no effect. Might just remove that one. Also added an extra if block in Reductio so it doesn't bother creating negative rules between two items in the same category.

When thinking about where the function 'enterCategoryValues' should really live I realised that the current method of tagging a puzzle in need of calculators is pretty slim. The keyword(s) are attributes of the whole puzzle, not the individual categories. Might have to change this in the source, as they do really belong with the categories and not the puzzle as a whole, though it is nice to be able to see straight off what specialties a puzzle uses as a gauge of difficulty.
----------
Jul 8th 
Second puzzle was actually much simpler, involving only direct relations, and was solved first time in 6 turns.
Puzzle three, the first 4x4, was inconclusive. Investigating why, this turned out to be because a negative relation needed to be entered in the category for an item (C4) which was added as a positive match to one item in the category so that another item could be deduced (!C2, !C3, !C4, => C1). Will add this to the category's method of adding an item.
Added this extra stage to the category but also found a couple of bits to fix: One of the reasons for many repeated relations out of Reductio was a list of negatives being looked for possible cross-reference relations was not being deduplicated before processing. Added in a Distinct. Also added in a small clause to the checkForMatch function so that it doesn't check, find three negatives for a category and produce a positive relation for the one remaining if this is already known. Puzzle three completes, but takes 106 turns. Don't know if this is due to the increase in size or redundant rule placement. Maybe should prioritise for next work session the emphasis on positive relations.

As the timing of all tests has so far been tiny, the speed of the test seems like a less scientific way to test the algorithm's effectiveness compared to the number of turns it takes to find the solution. As I am considering just in the cause of final development of this stage the queue-jumping of positive relations for processing, this ties in with my belief that potentially dropping in positives as early as possible will increase efficiency. Will therefore create the method with positive relation shifting as the alternative, second, model. The other deviation in algorithmic methods that was proposed was to avoid performing a check of reduction to absurdium until after all of the main rules have been considered. Even after watching the first few debug runs, however, it became obvious that performing an absurdium check after every rule consideration was redundant. Maybe in Algorithm 2 it can be reinstated for after every positive rule is considered (or else every 8th).
----------
Jul 10th
Decided that considerRelationToCategory shouldn't be in Deducer, but Category. Moved it but then the inverse, which relies on telling another category to update its members can't be called. But considering each rule is considered by each category in turn, this actually shouldn't matter. Switched deducers considerRelationToCategories to call the function in the categories rather than in itself and the test still passed, completing the puzzle in exactly the same number of turns. Good good.
After moving this and thinking about the bigger picture, I decided that it would be better if the category adding a matched item triggered an event that the Solution class would (indirectly) respond to, rather than having a separate stage for the Solution class to consider rules within Deducer's Go() method. This seems neater and may result in quicker solution if this is triggered also at the point at which a positive relation is created, rather than just applied. Will plug in and see the results.
WIN! Puzzle 3 is now solved in just 55 turns! Time halved! Coding is magic. Better than the reduction in turns... the third test puzzle just completed in 8ms, whereas the quickest I'd seen it previously was ~80ms.
----------
Jul 11th
Spoke to Roman and Michael at BBK and in explaining the difficulty I found in finding a good place for the Puzzle class, I realised that it could possibly be broken down. Each user of the puzzle would have a PuzzleBuilder and would be fed just the bits it's interested in with Controller holding the master information, as provided by the input Puzzle (i.e. as Representation has it). Parser and Logic would have their own PuzzleBuilder classes which would implement CleverZebra.IPuzzleBuilder and of the potential interface methods, implement just the ones it needs. This would be better from an Object-Oriented point of view, but the fellas said I should worry about the program actually doing what it needs to much more than the manner in which it does so, by which standard the current method of them all using the Representation.Puzzle class is fine.
* Make another Event/EventGenerator/EventListener set for SolveComplete which could report back to Controller the success, time taken and number of turns that Deducer took to reach its conclusion.
---------
Jul 12th
SolveCompleteEvent in action. Unlike my little finger. Results passed to Controller.
-------
Jul 13th
Added a fourth test, a 4x5. Originally failed because I mistranslated a rule but also meant I spotted that the solution needed an extra conditional in place to prevent a rule being added on a new line if there was already a potential gap in lines currently filled. Quite surprised this didn't cause any issues before now. Must be rare that the puzzle writers allow you to complete a whole row before lots of potential pairings are in place. Due to the code change required I will add in one more test.
... And just as well. Found a new relation type! "Oliver Ofgard is clearing a step at a house numbered higher than the other resident clearing a step". There are two step options, "Back step" and "Front step" and whilst the first bit (Oliver is clearing a step) can be translated as a list of negatives rather than creating an OR rule, there's no current way of writing up the comparative relation to the other one-of-steps. A simple If.. Then.. Else will be enough to represent this clue. 
?A4=C1?A4(D)>C3(D):A4(D)>C1(D)
How to handle this clue? Before the first part is known, the resulting statement cannot be considered, unless both of the second parts (C3(D), C1(D)) are known, in which case the first part can be handled. Maybe it could be coupled with an inverse therefore:
?C3(D)>C1(D)?A4=C3:A4=C1
How Deducer should handle Conditionals: They are kept until the front condition can be answered, at which point they simply return the correct new relation for processing and are removed from the clues bank.
ConditionalRelation class created. Now to add logic to Deducer...
* A reminder note that Number calculator doesn't actually perform calculations yet, but is relying upon categories being translated into values of 1,2,3,4,5 with a standard interval between them, which is what the difference points to. In the fifth test there is a non-standard interval (1,2,3,5,6) and I'd imagine to solve the puzzle the calculator will need to know that the higher item cannot be 5 as there is no 4 for the lower item to be (and vice versa) when given x(Y)-x'(Y)=1.
Puzzle five causes a particular situation that is difficult to mechanise for a compluter solver: There are three unassigned items in Category D and lots of comparative rules relating to them: B4(D) < A3(D), B4(D) > C1(D), A3(D) > C1(D). I think I need to introduce a triple relation (C1(D)<B4(D)<A3(D)) as these came from one clue (B4 is less than A3 but greater than C1). As long as this happens in any other situation requiring this logic, this will then fix it. May need to think of a way to automatically generate this from separate comparatives, though. Maybe a check as part of Absurdio? Will just add the Relation and logic for now.
Taking a step back because I managed to walk through the solution by hand without using a three way relative. I think it's just the missing calculator logic that's holding this one back. An extra negative result should be found by considering B1(D)-C4(D)=2 and the fact that not all potential values of D have a value 2 away. (e.g. in fifth test values are 1,2,3,5,6 and therefore B1 cannot be D6 because C4 cannot have the value 4. Need to add this in to the createNegativesToBounds function, but for now I must sleep.
*Might be a good idea to fix the addInverse to happen automatically as an event when a category adds a relation.
-------------
Jul 14th
Fifth test finally working! The Number Calculator's getImpossibles was checking the same item as the compared to and therefore missing situations where it could deduce a negative because the items higher were negated. So for B4(D)>C1(D) if we had established that B4 could not be D5 then it wasn't negating C1 against D4 because the function was looking first to see whether B4 was negated a D4 and would then have gone up to D5. Added one/Subtracted one from the starting index here for lower/higher comparatives and all tests working fine, including Problem 5. Finally!!! Taking 161 turns, though, so really need to add in that auto-Inverse event.

Time to move onto the Parser, I think. Starting to fill out the Category Dictionary, but it's bedtime now. Need to add one item into the dictionary's codes (A1) and words (Zachary) for each non-category-title word in each category.