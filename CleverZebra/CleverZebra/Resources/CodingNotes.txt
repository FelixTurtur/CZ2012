Jun 25th
First three tests completed successfully: Create_And_Test_Line, Test_AllButOneFound, Test_UnconclusiveResult. The Line class is the basic box that holds the contents of one category. The top row holds the index, the second the category identifier (A, B, C...) and the values if these are required. The third row is an array of strings that will hold known relational information. At this initial stage, only positive relations are cited in the third row. Might have to introduce a fourth row to hold negative relations. 
The idea for the line came from thinking about how to query a relative clause ("A1(B) - A2(B) = 25"). With the Line class, the whole statement can be passed to the Line and, as the values are held for comparative items, it can deduce and return any statements based on the information it holds (e.g. "A1 != B1; A2 != B5").

Still need to reconsider First Order Logic to see if I can use that as the basic semantic representation of such clauses, or whether another translation will have to happen later for the prover to keep things simple and manageable here.
------------

Jun 29th
After initially creating just one Relation class to hold all rule variants, it became apparent that a bit of inheritance would better handle the different logic required for most methods depending on the rule type. A factory was therefore created to control creation logic.

Added a fourth row to the Line class to hold information on negative relations.

Spent a while trying to think of a good name for "considerRelation", a function that passes a rule to a Line and returns true or false if the Line was able to use it. As a Line might create more rules in the process of considering a relation, this may need to be rethinked. Perhaps it's the collection of rules that uses the Line, and not vv?

Have created a namespace called Representation which has the characters I've chosen to use in Relations for equality, comparison and ownership. The items here are referenced by Relation classes when identifying items within a rule and checking the rule type.

Created a basic exception class for use when attempting to retrieve a specific item but it is not clear which item is desired. Need to read more about custom exceptions in C#. It's called InconclusiveException, but is currently specific to one scenario.

Created a separate test for the Relation class. (Tests were created in the LineTest file originally.)

After debating where to store the considerRelation function, given it's use of both a line and a relation, a brains class, Deducer, was created and so begins the step-by-step logical processing.
------------

Jun 30th
Exciting morning. Have created a family of Calculators which will perform the necessary calculation of relative items for a Line. The Line class holds a Calculator, which is initialised at the same time as a Line is created with a keyword. This keyword determines the type of Calculator that will be created. So far only the NumberCalculator is functional. These can be created as puzzles require. When a new keyword is encountered the logic for it will be held in Representation.Relations and the Calculator class.

Lines can now consider quantified relative numeric rules. 

Also created the DeducerTest file to complete the parts of Deducer begun last night. The Deducer holds a collection of lines, created based on the size of the puzzle.

Line now works with the calculator and comparative terms to understand relative relations! Need to build some tests, tho.
-----------

Jul 3rd
Slow day at work, so worked on getting VS2012 up in office to enable working from work and home. Once complete, got to fixing the UI a bit. There are now functioning switches from the main menu to settings window and the basic solver window, although nothing happens in the latter yet.
Filled in some basic ideas for settings options. 

Created a base file, Controller, to be the cross-module file that will use the individual modules to control the whole software as it works together. This was not created from a test file, as whether it would work was a test in itself with help from IDE hints.

Renamed Line to Category to use the abstract object it represents, not a name linked to its representation in code. Code is therefore now full of cats...	  

Created the shell of the Parser module and a few shells of classes it will need to allow build success.
Created a shell of the all-important Puzzle class.
-------------

Jul 6th
Let's get to it!
Might leave UI for a bit and assume all methods of Controller can populate UI elements and respond to events from UI. Don't like the tight coupling of UI elements to the controller anyway, although the Controller is quite coupled to the specific modules too. Might look for a way to add another layer of abstraction in the mix when it's time to put these two parts together.

Introduced CategoryBuilder to avoid Category having several constructors available. (Added InternalsVisibleTo attribute in CleverZebra for LogixTests to keep internals internal.)

Started rearranging modules into actual separate projects as otherwise they're not really independent entities. Now everyone needs references adding, but this suggests I've not gotten the coupling right. Need to work out what the interface should be between the CleverZebra project running everything and the now-separate components, Logix and Parser. Will cheat for now and add the references whilst waiting for a spot of guidance and lunching.

No guidance received, but by separating out the Representation classes - Puzzle, Solution, Relations - each module now references these and CZ also references Logix and Parser, so coupling is much better. If the representation of anything were to change then I'd want each concrete item to derive from an interface and this interface is what my modules would reference... but I don't think this will happen in the course of this project and so won't spend time adding in that layer of abstraction.

TODO: Think about how exceptions will be handled, i.e. passing feedback to the GUI so that it can continue.

Whilst translating the first puzzle into statements for testing, I realised the Logix unit may not need to know anything about the values and comparative terms. The parser should be translating them sufficiently that there remains no need for the Logix unit to do so. "Zachary lost his hat two days before Gareth" should be translated simply to A1(B)-A2(B)=2 if 2 is the index difference representing two days. If it is more complicated - say unequally separated monetary amounts, should this be taken into full consideration in the parser, however? I think the difference should be the number of units and logix should check whether each item is separated by one unit (easy) or whether it's a varying amount. This means Parser will be leaving numbers as they are, (1 day, £50) and Logix will be deciding what this means in relation to the available options.

Spent many, many hours getting the Deducer very nearly (hopefully...) solving the first test puzzle. Properly expanded the solving algorithm in Deducer.Go() to include check stages. There's a constant for the maximum number of turns the deducer should attempt to solve the puzzle in and one for the number of rules it should get from the "Grid Check" before returning to the main clues.
Latest bug - when we finally get the deduced rule that'll set 'em all on fire, cat.findTarget in considerRelationToCategory bombed with a null value. Walk through that one as the comparative rule is finally handled through the section where one value is known and we should be on the home straight.
------------

Jul 7th
After realising the checkDeductibles wasn't looking for all-but-one-negated and adding that in, the first problem was successfully solved. It took 57 turns, which is pretty lame, though. I think this is because it adds every reverse negative relation in there too - the equivalent of completing all the crosses even when there's only one tick left and it's coming. In a 4 x 3 puzzle there are only a total of 51 squares in the grid, though, so this definitely isn't that efficient. 

Next up is to actually return the solution in words for Deducer and then play with the ordering of the Deducer's Go() algorithm to see if the number of turns can be improved. Even though this only takes 49ms to run to completion. Ah, digital magickery.

After lunch... Solution returned was actually incorrect. Looking into it this was because the Reductio function removed the comparative relation and I'd actually typed it up the wrong way round anyway. a few things to work on: Prevent Reductio from dropping relative relations, set up comparative logic to use the calculator properly (Values might have to be set for the particular test problem being used), potentially limit the frequency with which Reductio is called and maybe push discovered positive rules further up the queue to help speed up resolution.